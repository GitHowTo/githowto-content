---
title: "28. Перебазування"
---

### Цілі

- Використовувати команду `rebase` замість команди `merge`.

Ми повернули гілку `style` до стану перед першим злиттям. В гілці `main` є дві коміти, яких зараз немає у гілці `style`: новий файл `README` і конфліктна зміна у файлі `index.html`. Цього разу ми перенесемо ці зміни до гілки `style` за допомогою команди `rebase`, а не `merge`.

## _01_ Перебазуйте гілку `style` на `main`.

<Run>
```
git switch style
git rebase main
git status
```
</Run>

<Output>
```git
==include[output/28-01.txt]
```
</Output>

Знову виник конфлікт! Зверніть увагу, що конфлікт стався в `hello.html`, а не в `index.html`, як минулого разу. Це тому, що `rebase` був у процесі застосування змін `style` поверх гілки `main`. У той момент в гілці `main` ще не було перейменовано файл `hello.html`, тому він все ще має стару назву.

При злитті виник би "зворотній" конфлікт. Під час злиття зміни гілки `main` були б застосовані поверх гілки `style`. У гілці `style` файл перейменовано, тому конфлікт виник би у файлі `index.html`.

<File file="hello.html">
```html
==include[output/28-01-1.txt]
```
</File>

## _02_ Розв'яжіть конфлікт

Сам конфлікт можна усунути так само, як ми це робили раніше. По-перше, ми відредагуємо файл `hello.html`, щоб він відповідав нашим очікуванням.

<File file="hello.html">
```html
<!-- Author: Alexander Shvets (alex@githowto.com) -->
<html>
  <head>
    <title>Hello World Page</title>
    <link type="text/css" rel="stylesheet" media="all" href="style.css" />
  </head>
  <body>
    <h1>Hello, World!</h1>
    <p>Let's learn Git together.</p>
  </body>
</html>
```
</File>

Але після цього нам не потрібно комітити зміни. Ми можемо просто додати файл до індексу і продовжити процес перебазування. Ось за що я люблю `rebase`! Ця команда дозволяє мені усувати конфлікти, не створюючи купу потворних конфліктів злиття.

> Для простоти ми можемо додати всі зміни, використовуючи `.`, що означає шлях до поточної директорії. Git інтерпретує це як «додати всі зміни з поточної директорії та її піддиректорій».

<Run>
```
git add .
git rebase --continue
```
</Run>

Тут, найімовірніше, Git знову відкриє редактор, щоб дозволити нам змінити текст коміту. Ми можемо залишити текст без змін. Після збереження змін Git завершить процес `rebase`, і ми зможемо виконати наступні команди:

<Run>
```
git status
git log --all --graph
```
</Run>

<Output>
```git
==include[output/28-02.txt]
```
</Output>


## _03_ Злиття VS перебазування

Кінцевий результат перебазування дуже схожий на результат злиття. Гілка `style` зараз містить всі свої зміни, а також всі зміни гілки `main`. Однак, дерево комітів значно відрізняється. Дерево комітів гілки `style` було переписано таким чином, що гілка `main` є частиною історії комітів. Це робить ланцюг комітів лінійним і набагато більш читабельним.

## _04_ Коли використовувати команду `rebase`, а коли команду `merge`?

Використовуйте команду `rebase`:

- Коли ви підтягуєте зміни з віддаленого репозиторія і хочете злити їх до вашої локальної гілки.
- Якщо ви хочете, щоб історія комітів була лінійною і легкою для читання.

Не використовуйте команду `rebase`:

- Якщо поточна гілка є загальнодоступною. Перезапис таких гілок заважатиме роботі інших членів команди.
- Коли важлива _точна_ історія гілки комітів (оскільки команда `rebase` переписує історію комітів).

Враховуючи наведені вище рекомендації, я вважаю за краще використовувати `rebase` для короткострокових, локальних гілок, а команду `merge` — для гілок у публічному репозиторії.