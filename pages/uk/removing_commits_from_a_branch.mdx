---
title: "15. Видалення комітів з гілки (revert)"
---

### Цілі

- Навчитися видаляти останні коміти з гілки.

`revert` з попереднього розділу є потужною командою, яка дозволяє скасувати будь-які коміти у репозиторії. Однак, і оригінальний і «скасований» коміти видно в історії гілки (при використанні команди `git log`).

Часто ми робимо коміт, і відразу розуміємо, що це була помилка. Було б непогано мати команду «повернення», яка дозволила б нам удати, що неправильного коміту ніколи й не було. Ця команда навіть запобігла б появі небажаного коміту в історії `git log`.

## _01_ Команда `reset`

Ми вже бачили команду `reset` і використовували її для узгодження області підготовки з обраним комітом (у попередньому уроці ми використовували коміт `HEAD`).

Якщо виконати команду `reset` із зазначенням посилання на коміт (позначка `HEAD`, хеш коміту, назва тегу або гілки тощо), то команда...

1. Змінить поточну гілку, щоб вона вказувала на зазначений коміт.
2. Опціонально відкотить область підготовки до відповідності із зазначеним комітом.
3. Опціонально відкотить робочу директорію до відповідності із зазначеним комітом.

## _02_ Перевірте нашу історію

Перевірмо нашу історію комітів.

<Run>
```
git log
```
</Run>

<Output>
```git
==include[output/15-01.txt]
```
</Output>

Ми бачимо, що два останніх коміти в цій гілці - «Oops» і «Revert Oops». Видалімо їх за допомогою команди відкочування `reset`.

## _03_ Для початку позначте цю гілку

Але перш ніж видалити коміт, позначмо останній коміт тегом, щоб потім можна було його знайти.

<Run>
```
git tag oops
```
</Run>

<Output>
```git
==include[output/15-02.txt]
```
</Output>

## _04_ Відкіт до коміту, що передує до `oops`

Дивлячись на історію логу (див. вище), ми бачимо, що коміт з тегом `v1` є комітом, попереднім до помилкового коміту. Скиньмо гілку до цієї точки. Оскільки гілка має тег, ми можемо використовувати ім'я тегу в команді відкоту `reset` (якщо вона не має тега, ми можемо використовувати хеш коміта).

<Run>
```
git reset --hard v1
git log
```
</Run>

<Output>
```git
==include[output/15-03.txt]
```
</Output>

Наша гілка `main` тепер вказує на коміт `v1`, а комітів "Revert Oops" і "Oops" в гілці вже немає. Параметр `--hard` вказує, що робоча директорія повинна бути відновлена до того стану, що відповідає `HEAD`-коміту гілки.

## _05_ Нічого ніколи не губиться

Що ж трапляється з помилковими комітами? Виявляється, що коміти все ще знаходяться в репозиторії, ми все ще можемо на них посилатися. Пам'ятаєте, на початку цього уроку ми створили для скасованого коміту тег `oops`? Подивімось на _всі_ коміти.

<Run>
```
git log --all
```
</Run>

<Output>
```git
==include[output/15-04.txt]
```
</Output>

Ми бачимо, що помилкові коміти не зникли. Вони все ще знаходяться в репозиторії. Просто вони відсутні в гілці `main`. Якби ми не позначили їх тегами, вони як і раніше перебували б у репозиторії, але не було б жодної можливості посилатися на них, окрім як за допомогою хешів цих комітів. Коміти, на які немає інших посилань, залишаються в репозиторії до тих пір, поки не буде запущений збирач сміття.

## _06_ Небезпека відкочування

Відкочування в локальних гілках, як правило, безпечне. Наслідки будь-який «аварії», як правило, можна відновити простим відкочуванням до потрібного коміту.

Однак, якщо гілка вже стала загальнодоступною на віддалених репозиторіях, то відкочування може збити з пантелику інших користувачів гілки.